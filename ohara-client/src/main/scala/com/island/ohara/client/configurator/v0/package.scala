/*
 * Copyright 2019 is-land
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.island.ohara.client.configurator

import com.island.ohara.common.setting.{ConnectorKey, ObjectKey, SettingDef, TopicKey}
import com.island.ohara.common.util.CommonUtils
import com.island.ohara.kafka.connector.json.ConnectorDefUtils
import spray.json.{JsNull, JsValue, RootJsonFormat}

package object v0 {

  /**
    * the default group to all objects.
    * the group is useful to Ohara Manager. However, in simple case, the group is a bit noisy so we offer the default group to all objects when
    * input group is ignored.
    *
    * This field is protected since it is a "default" to all APIs scopes than a "global" default to whole project.
    * However, each APIs scope may have custom default value of group.
    */
  private[v0] val GROUP_DEFAULT: String = "default"
  val GROUP_KEY: String = "group"

  /**
    * Noted: there are other two definition having "name"
    * 1) ConnectorDefUtils.CONNECTOR_NAME_DEFINITION.key()
    * 2) StreamDefinitions.NAME_DEFINITION.key
    */
  val NAME_KEY: String = "name"

  /**
    * This reference ensures that the tags key in scala json is same to java json (connector metadata).
    * This a bit complicated code is what we had to "enjoy" as Ohara is a hybrid project consisting of scala and java.
    */
  val TAGS_KEY: String = ConnectorDefUtils.TAGS_DEFINITION.key()
  val CLUSTER_KEY: String = "cluster"
  val FORCE_KEY: String = "force"
  val START_COMMAND: String = "start"
  val STOP_COMMAND: String = "stop"
  val PAUSE_COMMAND: String = "pause"
  val RESUME_COMMAND: String = "resume"
  val DEFINITIONS_COMMAND: String = "definitions"

  /**
    * In this APIs we have to integrate json format between scala (spray-json) and java (jackson).
    * The JsNull generated by spray-json confuse jackson to generate many "null" object. We remove the key related to
    * JsNull in order to avoid passing null to jackson.
    */
  private[v0] def noJsNull(fields: Map[String, JsValue]): Map[String, JsValue] = fields.filter {
    _._2 match {
      case JsNull => false
      case _      => true
    }
  }

  private[v0] def noJsNull(jsValue: JsValue): Map[String, JsValue] = noJsNull(jsValue.asJsObject.fields)

  private[v0] implicit val OBJECT_KEY_FORMAT: RootJsonFormat[ObjectKey] = JsonRefiner[ObjectKey]
    .format(new RootJsonFormat[ObjectKey] {
      import spray.json._
      override def write(obj: ObjectKey): JsValue = ObjectKey.toJsonString(obj).parseJson
      override def read(json: JsValue): ObjectKey = ObjectKey.toObjectKey(json.toString())
    })
    .nullToString(GROUP_KEY, () => GROUP_DEFAULT)
    .rejectEmptyString()
    .refine

  implicit val TOPIC_KEY_FORMAT: RootJsonFormat[TopicKey] = JsonRefiner[TopicKey]
    .format(new RootJsonFormat[TopicKey] {
      import spray.json._
      override def write(obj: TopicKey): JsValue = try TopicKey.toJsonString(obj).parseJson
      catch {
        case e: Throwable =>
          throw DeserializationException(
            msg = e.getMessage,
            cause = e,
            fieldNames = List("group", "name")
          )
      }
      override def read(json: JsValue): TopicKey = TopicKey.toTopicKey(json.toString())
    })
    .nullToString(GROUP_KEY, () => TopicApi.GROUP_DEFAULT)
    .rejectEmptyString()
    .refine

  private[v0] implicit val CONNECTOR_KEY_FORMAT: RootJsonFormat[ConnectorKey] = JsonRefiner[ConnectorKey]
    .format(new RootJsonFormat[ConnectorKey] {
      import spray.json._
      override def write(obj: ConnectorKey): JsValue = try ConnectorKey.toJsonString(obj).parseJson
      catch {
        case e: Throwable =>
          throw DeserializationException(
            msg = e.getMessage,
            cause = e,
            fieldNames = List("group", "name")
          )
      }
      override def read(json: JsValue): ConnectorKey = ConnectorKey.toConnectorKey(json.toString())
    })
    .nullToString(GROUP_KEY, () => ConnectorApi.GROUP_DEFAULT)
    .rejectEmptyString()
    .refine

  /**
    * exposed to configurator
    */
  private[v0] implicit val SETTING_DEFINITION_JSON_FORMAT: RootJsonFormat[SettingDef] =
    new RootJsonFormat[SettingDef] {
      import spray.json._
      override def read(json: JsValue): SettingDef = SettingDef.ofJson(json.toString())

      override def write(obj: SettingDef): JsValue = obj.toJsonString.parseJson
    }

  /**
    * docker does limit the length of name (< 64). Since we format container name with some part of prefix,
    * limit the name length to one-third of 64 chars should be suitable for most cases.
    */
  private[this] val LIMIT_OF_NAME_LENGTH: Int = 20

  /**
    * use basic check rules of creation request for json refiner.
    * 1) reject any empty string.
    * 2) nodeName cannot use "start" and "stop" keywords.
    * 3) nodeName cannot be empty array.
    * 4) imageName will use {defaultImage} if not defined.
    * 5) name must satisfy the regex [a-z0-9] and length <= 20
    * 6) name will use randomString if not defined.
    * 7) tags will use empty map if not defined.
    * @param defaultImage this cluster default images
    * @tparam T type of creation
    * @return json refiner object
    */
  private[v0] def basicRulesOfCreation[T <: ClusterCreationRequest](defaultImage: String): JsonRefiner[T] =
    JsonRefiner[T]
      .rejectEmptyString()
      .arrayRestriction("nodeNames")
      // we use the same sub-path for "node" and "actions" urls:
      // xxx/cluster/{name}/{node}
      // xxx/cluster/{name}/[start|stop]
      // the "actions" keywords must be avoided in nodeNames parameter
      .rejectKeyword(START_COMMAND)
      .rejectKeyword(STOP_COMMAND)
      // the node names can't be empty
      .rejectEmpty()
      .toRefiner
      .nullToString("imageName", defaultImage)
      .stringRestriction(NAME_KEY)
      .withNumber()
      .withLowerCase()
      .withLengthLimit(LIMIT_OF_NAME_LENGTH)
      .toRefiner
      .nullToString(NAME_KEY, () => CommonUtils.randomString(10))
      .nullToEmptyObject(TAGS_KEY)

  /**
    * use basic check rules of update request for json refiner.
    * 1) reject any empty string.
    * 2) nodeName cannot use "start" and "stop" keywords.
    * 3) nodeName cannot be empty array.
    * @tparam T type of update
    * @return json refiner object
    */
  private[v0] def basicRulesOfUpdate[T <: ClusterUpdateRequest]: JsonRefiner[T] = JsonRefiner[T]
    .rejectEmptyString()
    .arrayRestriction("nodeNames")
    // we use the same sub-path for "node" and "actions" urls:
    // xxx/cluster/{name}/{node}
    // xxx/cluster/{name}/[start|stop]
    // the "actions" keywords must be avoided in nodeNames parameter
    .rejectKeyword(START_COMMAND)
    .rejectKeyword(STOP_COMMAND)
    // the node names can't be empty
    .rejectEmpty()
    .toRefiner
}
